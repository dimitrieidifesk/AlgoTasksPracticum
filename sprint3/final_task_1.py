"""
https://contest.yandex.ru/contest/23815/run-report/120682025/

-- ПРИНЦИП РАБОТЫ --
  Реализован бинарный поиск. Он основан на принципе разделения отсортированного или частично отсортированного (сломанного)
массива на пополам при каждом рекурсивном вызове. Используя метод двух указателей, мы можем определить находится ли искомое число
в участке, ограниченном левым указателем и центральным звеном или же правым указателем и центральным звеном. В зависимости от этого
мы выбираем участок для следующего рекурсивного вызова. Базовый случай для выхода рекурсии - если центральный элемент участка равен
искомому числу или если левая граница стала больше правой (в этом случае элемент не найден, возвращаем -1).

  Основное отличие поиска в сломанном массиве от поиска в отсортированном массиве в том, что одна из половинок
массива может быть не отсортирована. В отсортированной части мы всегда можем точно определить находиться ли там искомое нам число за O(1).
Если искомое число находится в отсортированной части, то рекурсивный процесс дальше ничем не отличается от обычного бинарного поиска,
описанного в первом абзаце.
  Если искомого числа нет в отсортированной части, то мы снова вызываем функцию, только для не отсортированной части, где
опять же происходит определение отсортированной и не отсортированной частей и т.д. Таким образом сдвиг исходной отсортированной
последовательности никак не повлияет на временную сложность решения.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Проверка нахождения элемента происходит по границам только отсортированных участков. Не отсортированные участки будут разделены и проверены
в следующих рекурсивных вызовах, если в отсортированной части элемент не найден.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
На каждом рекурсивном вызове происходит деление массива пополам. Алгоритм работает до тех пор, пока искомое значение не окажется центральным
элементом полученного интервала. В худшем случае для этого понадобится O(log n) времени.

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Пространственная сложность зависит только от количества чисел в исходной последовательности - O(n).
"""
from typing import List


def binary_search(target: int, arr: List[int], left: int, right: int) -> int:
    if left > right:
        return -1

    mid = left + (right - left) // 2
    if arr[mid] == target:
        return mid
    if arr[left] <= arr[mid]:
        if arr[left] <= target < arr[mid]:
            return binary_search(target, arr, left, mid - 1)
        else:
            return binary_search(target, arr, mid + 1, right)
    else:
        if arr[mid] < target <= arr[right]:
            return binary_search(target, arr, mid + 1, right)
        else:
            return binary_search(target, arr, left, mid - 1)


def broken_search(nums, target) -> int:
    return binary_search(target, nums, 0, len(nums) - 1)


def test():
    arr = [19, 21, 100, 101, 1, 4, 5, 7, 12]
    assert broken_search(arr, 5) == 6
