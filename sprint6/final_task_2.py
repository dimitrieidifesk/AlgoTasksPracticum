"""
https://contest.yandex.ru/contest/25070/run-report/134625909/

-- ПРИНЦИП РАБОТЫ --
   Для каждой не посещенной координаты водной карты ищем землю #. Если нашли землю, запускаем обход земли для определения размеров.
   В get_land_size используем очередь из collections.deque для оптимизации работы алгоритма при больших вх.данных.
   Вытаскивая из очереди по одной новой координате, мы проверяем соседние координаты и если они так же являются #, кладем их в очередь для дальнейшей обработки.
   Обработанные участки карты помечаем "х", что бы не ходить кругами по острову.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
    Когда очередь опустеет, это будет значить, что мы прошли весь остров и сохранили его размер в size. Дважды одни и те же координаты алгоритм проверять не будет,
    т.к. каждый обработанный участок помечаем как "х".

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
    Операции с очередью collections.deque выполняются за O(1)
    Проверка каждой координаты = O(4 * n * m) // x4 потому что для каждой координаты проверится 4 направления перемещения. (Можно кешировать проверенные корды,
        но поскольку проверка соседнего участка выполняется за O(1), нет смысла тратить память на кеш)
    Простроение карты = O(n * m)
    -----------------------------
    Временная сложность алгоритма = O(4 * n * m) + O(n * m) = O(n * m)

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
    Хранение карты = O(n * m)
    Хранение найденных островов = O(n * m) // Хотя если все коорданаты будут островами, то это 1 остров. Макс кол-во островов будет в том случае,
        если они расположены в шахматном порядке размером в 1 клетку, но округлим такое кол-во островов до O(n * m)
    Очередь = O(n * m) // Тоже если округлить
    -----------------------------
    Пространственная сложность алгоритма = O(n * m) + O(n * m) + O(n * m) = O(n * m)
"""

from collections import deque

n, m = map(int, input().split())
map = [list(input().strip()) for _ in range(n)]
movements = [(0, 1), (0, -1), (1, 0), (-1, 0)]
lands = []


def is_land(x, y):
    return x >= 0 and y >= 0 and x < n and y < m and map[x][y] == "#"


def get_land_size(start_x, start_y):
    queue = deque([(start_x, start_y)])
    map[start_x][start_y] = "x"
    size = 0

    while queue:
        cur_x, cur_y = queue.popleft()
        size += 1
        for dx, dy in movements:
            new_x, new_y = cur_x + dx, cur_y + dy
            if is_land(new_x, new_y):
                map[new_x][new_y] = "x"
                queue.append((new_x, new_y))

    return size


for cord_x in range(len(map)):
    for cord_y in range(m):
        point = (cord_x, cord_y)
        if map[cord_x][cord_y] == '#':
            land_size = get_land_size(cord_x, cord_y)
            lands.append(land_size)

print(len(lands), max(lands) if lands else 0)
