"""
https://contest.yandex.ru/contest/25070/run-report/134621811/

-- ПРИНЦИП РАБОТЫ --
    Реализован алгоритм для получения максимального оставного дерева в неориентированном графе. Использовался алгоритм Прима.
    Граф хранится в виде списка взвешанных ребер между вершинами (объект Edge)
    Множество added - уже обработанные вершины
    Множество not_added - вершины, предстоящие обработать
    очередь edges - приоритетная очередь из библиотеки queue.PriorityQueue

    1. Выбираем первую вершину помечаем её как обработанную. Кладем в очередь все смежные с ней вершины, при условии, что они еще не обработаны.
    Приоритетная очередь отсортирует помещенные вершины по весу со знаком "-" (для извлечения в порядке "от меньшего к большему")
    2. До тех пор, пока очередь не пуста, проделываем операции из п1 с каждой вершиной, извлеченной из очереди. При этом инкрементируем max_tree_weight (макс вес остовного дерева)

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
    Поскольку алгоритм выбирает вершины для обработки, исходя из веса ребра, в остовном дереве будут только ребра, образующие максимально тяжелое остовное дерево.
    Циклов в остовном дереве не будет, т.к. мы не проверяем вершины, уже добавленные в added

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
    Операции с очередью:
        Вставка элемента в приоритетную очередь = O(log n)
        Извлечение элемента из приоритетной очереди = O(log n)
        n в данном случае = кол-во элементов в очереди, но допустим n = |E|
        -----------
        Общ.временная сложность операций с очередью = O(log(|E|)) + O(log(|E|)) = O(log(|E|))
    Построение графа = O(|E|)
    Алгоритм обойдет все вершины в цикле while = O(|V|)
    -----------------------------
    Временная сложность алгоритма = O(|E| + |V| + |E| * log(|E|))

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
    Хранение графа = O(|E|)
    Множество обработанных вершин added = O(|V|)
    Множество не обработанных вершин not_added = O(|V|)
    Очередь ребер для обработки edges = O(|E|) (Возможно тогда, когда мы начинаем с вершины максимальной степени,
    а у остальных вершин степень 1 (Все вершины смежны с одной - начальной))
    -----------------------------
    Пространственная сложность алгоритма = O(|E| + |V| + |V| + |E|) = O(|E|)
"""


from queue import PriorityQueue
from typing import List


class Edge:
    def __init__(self, vertex, weight):
        self.vertex = vertex
        self.weight = weight


n, m = map(int, input().split())

graph: List[List[Edge]] = [[] for _ in range(n)]

for _ in range(m):
    u, v, w = map(int, input().split())
    graph[u - 1].append(Edge(v - 1, w))
    graph[v - 1].append(Edge(u - 1, w))

added = set()
not_added = set(range(n))
edges = PriorityQueue()

max_tree_weight = 0


def add_vertex(v):
    added.add(v)
    not_added.remove(v)
    for edge in graph[v]:
        if edge.vertex not in added:
            edges.put((-edge.weight, edge.vertex))


start_vertex = 0
add_vertex(start_vertex)

while not_added and not edges.empty():
    weight, end_vertex = edges.get()
    if end_vertex in not_added:
        max_tree_weight -= weight
        add_vertex(end_vertex)

if not_added:
    print("Oops! I did it again")
else:
    print(max_tree_weight)
